[MDN Notes: Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

---


## üî∑ THEORY: What Are Promises in JavaScript?

### ‚úÖ Definition:

A **Promise** is an **object** representing the eventual **completion or failure** of an asynchronous operation and its resulting value.

---

## üî∑ WHY Are Promises Used?

### üß† Reason:

In JavaScript, asynchronous tasks like:

* API calls
* Network requests
* File operations
* Timeouts

‚Ä¶were traditionally handled using **callbacks**, which led to **Callback Hell**‚Äîdeeply nested functions that were hard to manage or debug.

### ‚úÖ Promises solve this by:

* Providing cleaner syntax (`then`, `catch`, `finally`)
* Avoiding nesting by chaining
* Making code easier to understand

---

## üî∑ HOW TO CREATE A PROMISE?

```js
const promiseOne = new Promise(function(resolve, reject) {
    // Do an async task
    setTimeout(function () {
        console.log("Async Task is Complete");
        resolve();
    }, 1000);
});
```

### üìò Explanation:

* `new Promise()` creates a **promise object**
* It takes a **callback function** with two arguments: `resolve` and `reject`
* After 1 second, `resolve()` is called (it marks the promise as **fulfilled**)

---

## üî∑ HOW TO CONSUME A PROMISE?

```js
promiseOne.then(function() {
    console.log("Promise Consumed");
});
```

### üìò Explanation:

* `.then()` is executed **only when the promise is resolved**
* It registers a **callback function** to run after successful completion

---

## üî∑ SECOND CODE SNIPPET

```js
new Promise(function(resolve, reject){
    setTimeout(function(){
        console.log("Async Task Two");
        resolve();
    }, 1000);
}).then(function(){
    console.log("Async 2 resolved");
});
```

### üìò Explanation:

* Here, we are **creating and consuming** a promise **immediately**.
* After 1 second:

  * `console.log("Async Task Two")`
  * Then it resolves
  * `.then()` prints: `"Async 2 resolved"`

---

## üî∑ THIRD CODE SNIPPET

```js
const promiseThree = new Promise(function(resolve, reject) {
    setTimeout(() => {
        resolve({
            username: "Chai",
            email: "chai@example.com"
        });
    }, 1000);
});

promiseThree.then(function(user){
    console.log(user);
});
```

### üìò Explanation:

* After 1 second, `resolve()` passes an object `{username, email}`
* `.then()` receives that object and logs it

### üìå Key Point:

> **Data can be passed** to `.then()` via the `resolve()` function.

---

## üî∑ FOURTH CODE SNIPPET

```js
const promiseFour = new Promise(function(resolve, reject){
    setTimeout(function() {
        let error = true;
        if(!error){
            resolve({username: "hitesh", password: "123"});
        } else {
            reject("ERROR: Something went wrong");
        }
    }, 1000);
});

promiseFour
.then((user) => {
    console.log(user);
    return user.username;
})
.then((username) => {
    console.log(username);
})
.catch((error) => {
    console.log(error);
})
.finally(() => {
    console.log("The promise is either resolved or rejected");
});
```

### üìò Explanation:

* **If `error` is `false`**: `resolve()` passes the user object
* **If `error` is `true`**: `reject()` throws an error
* `.catch()` handles errors
* `.finally()` always runs ‚Äî no matter success or failure

---

## üî∑ FIFTH CODE SNIPPET (ASYNC/AWAIT)

```js
const promiseFive = new Promise(function(resolve, reject){
    setTimeout(function() {
        let error = true;
        if(!error){
            resolve({username: "javascript", password: "123"});
        } else {
            reject("ERROR: JS went wrong");
        }
    }, 1000);
});

async function consumePromiseFive() {
    try {
        const response = await promiseFive;
        console.log(response);
    } catch (error) {
        console.log(error);
    }
}

consumePromiseFive();
```

### üìò Explanation:

* `async` makes the function return a promise
* `await` pauses code execution until the promise resolves or rejects
* `try/catch` is used to handle errors cleanly

### ‚úÖ `async/await` is a **cleaner way** to work with Promises

---

## üî∑ SIXTH SNIPPET (FETCH API + PROMISES)

```js
fetch('https://jsonplaceholder.typicode.com/todos/1')
.then((response) => {
    return response.json();
})
.then((data) => {
    console.log(data);
})
.catch((error) => console.log(error));
```

### üìò Explanation:

* `fetch()` returns a Promise
* `.json()` also returns a Promise
* `then()` handles each step
* `catch()` handles errors (like network failures)

---

## üî∑ BONUS: PROMISE.ALL

> `Promise.all([promise1, promise2, ...])` is a method that waits for **all promises** in the array to be resolved or **any one to reject**.

### üìå Example Use Case (Not in your code):

```js
Promise.all([
    fetch('url1'),
    fetch('url2'),
    fetch('url3')
])
.then(([res1, res2, res3]) => {
    // Handle all responses
})
.catch((err) => {
    console.log("At least one failed:", err);
});
```

---

## üìå SUMMARY OF IMPORTANT TERMS

| Term          | Description                                         |
| ------------- | --------------------------------------------------- |
| `Promise`     | A placeholder for future value from async operation |
| `resolve()`   | Marks the promise as **fulfilled**                  |
| `reject()`    | Marks the promise as **rejected**                   |
| `.then()`     | Called on successful resolve                        |
| `.catch()`    | Called when an error occurs                         |
| `.finally()`  | Always runs after resolve/reject                    |
| `async/await` | Syntactic sugar over Promises for cleaner syntax    |

---

## ‚ùìInterview Style Questions Answered:

### Q: What are promises?

A: Promises are JavaScript objects that represent the eventual result of an asynchronous operation.

### Q: Why are promises used?

A: To handle asynchronous operations in a cleaner and more maintainable way, avoiding callback hell.

### Q: How do you create a promise?

A: Using `new Promise(function(resolve, reject) {...})`

### Q: What is the use of resolve and reject?

A: `resolve()` marks success and sends a value to `.then()`. `reject()` marks failure and sends an error to `.catch()`.

### Q: How do you consume a promise?

A: With `.then()` for success, `.catch()` for failure, and `.finally()` for post-processing.

---

Watch this lecture again